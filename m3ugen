#!/usr/bin/perl

# m3ugen - Recursive, multi-format m3u generation tool
# (c) 2004, 2005 Alex Malinovich (demonbane@the-love-shack.net)
# Released under the GPL
# See www.fsf.org for a full copy of the GPL.

# BUGS: Currently, m3ugen will only sort the playlist based on
#       the album and track number. It SHOULD also take into
#       consideration the DISCNUMBER tag, if present. At this
#       time, however, Audio::File (Audio::File::Tag to be
#       exact) does NOT support the DISCNUMBER tag, so this
#       feature cannot be implemented yet.
# NOTE: I have written a patch for Audio::File to handle the disc
# 	tags appropriately, however it has not been accepted into
# 	upstream yet. Using the patch this version of m3ugen will
# 	properly sort by disc number as well as album.
#
# TODO:	Make sure that all code is Unicode-friendly. Since OGG tags
# 	can be in Unicode the code should handle those strings
# 	appropriately.

$version="0.12";

use Audio::File;
use Cwd;
use Encode;
use File::Basename;
use File::Find;
use Getopt::Mixed 1.006;
use IO::Handle;

Getopt::Mixed::init("r recursive>r n no-path>n h help>h usage>h d debug>d a albums>a v version>v");
$Getopt::Mixed::ignoreCase = 0;
Getopt::Mixed::getOptions();

if ($opt_h) {
  print "Usage: m3ugen [OPTION]... SOURCE [M3UFILE]\n";
  print "Output an m3u playlist containing mp3, Ogg Vorbis, and FLAC files found in\n";
  print "SOURCE to M3UFILE if specified, STDOUT otherwise.\n\n";
  print "  -h, --help         display this screen and exit\n\n";
  print "  -r, --recursive    recursively search through directories\n";
  print "                     (default is specified directory ONLY)\n\n";
  print "  -a, --albums       create ALBUMNAME.m3u for each album in SOURCE\n";
  print "                     (implies M3UFILE behavior and ignores M3UFILE if specified)\n\n";
  print "  -n, --no-path      print paths relative to SOURCE\n";
  print "                     (default is to print full path)\n\n";
  print "  -d, --debug        print debugging output to STDERR\n\n";
  print "  -v, --version      print version information and exit\n\n";
  exit 0;
}

if ($opt_v) {
  print "m3ugen $version\n";
  exit 0;
}

if (!$ARGV[0]) {
  die "Please specify a directory to work on!\n\n";
}elsif (!-d $ARGV[0]) {
  die "Invalid directory!\n\n";
}

if ($ARGV[1]) {
  open(OUTPUT,">:utf8",$ARGV[1]) || die "Could not open $ARGV[1] for writing!\n";
}else {
  OUTPUT->fdopen(STDOUT, "w") || die "Could not redirect output!\n";
  binmode OUTPUT, ":utf8";
}

open(ERROR,">:utf8", "/dev/null");

if ($opt_d) {
  ERROR->fdopen(STDERR, "w");
  binmode ERROR, ":utf8";
}

print ERROR "SOURCE = \"$ARGV[0]\"\nM3UFILE = \"$ARGV[1]\"\n";

$workDir = Cwd::abs_path($ARGV[0])."/";

$currentDir = getcwd();

#for creating unique track numbers
$uniq = 1;

if (substr($workDir,0,1) ne '/') {
  $workDir = getcwd()."\/".$workDir;
}

if ($opt_r) {
  find(\&wanted, $workDir);
}else {
  chdir($workDir);
  foreach (glob("*.[Oo][Gg][Gg]"),glob("*.[Ff][Ll][Aa][Cc]"),glob("*.[Mm][Pp]3")) {
    print ERROR "found file = \"$_\"\n";
    push(@files,$workDir.$_);
  }
#  push(@files,glob("*.[Oo][Gg][Gg]"));
#  push(@files,glob("*.[Ff][Ll][Aa][Cc]"));
#  push(@files,glob("*.[Mm][Pp]3"));
}

foreach $filename (@files) {
  my $mediaFile = Audio::File->new("$filename");
  $filename = decode_utf8($filename);
  $artist = decode_utf8($mediaFile->tag->artist());
  $album = decode_utf8($mediaFile->tag->album());
  $disc = $mediaFile->tag->disc();
  $track = abs($mediaFile->tag->track());
  $title = decode_utf8($mediaFile->tag->title());
  $length = $mediaFile->audio_properties->length();

  print ERROR "artist = \"$artist\"\n";

  # The reason we're checking both track and album at the same time
  # here is because if we don't know the album the user is probably
  # generating a list for a directory of random songs, likely from
  # random albums. In this case, we assign a generic album name and
  # track number.
  #
  # TODO: This could be made more intelligent so that if the album
  # name doesn't exist but the track number does, we use the track
  # number IF it doesn't conflict with another one. If it does, we
  # give it one of the remaining available numbers.
  #
  # TODO: If the album is known but the tracks aren't, we could
  # still keep the album name. This poses problems if the user has
  # used the -a option, as this will open us to the possibility of
  # creating n random playlists. Perhaps finding an album name with
  # no track number will automatically disable the -a option?

  if (!$track || !$album) {
    print ERROR "Unknown album/track name\n";
    print ERROR "Assuming \"Unknown Album Name\" due to \"$album\".\n";
    print ERROR "Assuming track \"".$uniq++."\" due to \"$track\".\n";
    $album = "Unknown Album Name";
    $track = $uniq;
  }else {
    print ERROR "album = \"$album\"\n";
    print ERROR "track = \"$track\"\n";
  }

  if (!$disc) {
    print ERROR "Unknown disc number. Assuming 1.\n";
    $disc = 1;
  }else {
    print ERROR "disc = \"$disc\"\n";
  }

  print ERROR "title = \"$title\"\n";
  print ERROR "length = \"$length\"\n";

  $m3ulines = "#EXTINF:".$length.",".$artist." - ".$title."\n";
  if ($opt_n) {
    my $templine = ($filename ^ $workDir);
    # Remove any leading NULL characters. They cause problems in some
    # media players.
    $templine =~ s/\x00+//;
    $m3ulines .= $templine;
  }else {
    $m3ulines .= $filename;
  }
  $m3ulines .= "\n";

  $writeme{$album}[$disc - 1][$track - 1] = $m3ulines;
  print ERROR "m3ulines = \"$m3ulines\"\n";
}

foreach $albumname (keys %writeme) {
  if ($opt_a) {
    print ERROR "Generating -a list\n";
    close OUTPUT;
    open(OUTPUT,">:utf8", "$currentDir/$albumname.m3u") || die "Could not open $albumname.m3u for writing!\n";
  }else{
    print ERROR "Generating standard list\n";
  }
  print OUTPUT "#EXTM3U\n";
  print ERROR "albumname = \"$albumname\"\n";
  for ($discnumber = 0; $discnumber < ($#{$writeme{$albumname}} + 1); $discnumber++) {
    print ERROR "discnumber = \"".($discnumber+1)."\"\n";
    foreach $songname (@{$writeme{$albumname}[$discnumber]}) {
      print OUTPUT $songname;
    }
  }
}

close ERROR;
close OUTPUT;

sub wanted {
  if (-f $_) {
    print ERROR "-----------------\n";
    print ERROR "checking \"$_\"\n";
    my @fileParts = split(/\./);
    my $fileExt = lc(pop(@fileParts));
    print ERROR "fileExt = \"$fileExt\"\n";
    if ($fileExt eq "ogg" || $fileExt eq "flac" || $fileExt eq "mp3") {
      print ERROR "adding \"$_\" to \@files\n";
      push(@files, $File::Find::name);
    }
  }
}
