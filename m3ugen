#!/usr/bin/perl

# m3ugen - Recursive, multi-format m3u generation tool
# (c) 2004, 2005 Alex Malinovich (demonbane@the-love-shack.net)
# Released under the GPL
# See www.fsf.org for a full copy of the GPL.

# BUGS: Currently, m3ugen will only sort the playlist based on
#       the album and track number. It SHOULD also take into
#       consideration the DISCNUMBER tag, if present. At this
#       time, however, Audio::File (Audio::File::Tag to be
#       exact) does NOT support the DISCNUMBER tag, so this
#       feature cannot be implemented yet.
# NOTE: I have written a patch for Audio::File to handle the disc
# 	tags appropriately, however it has not been accepted into
# 	upstream yet. Using the patch this version of m3ugen will
# 	properly sort by disc number as well as album.

$version="0.14";

use Audio::File;
use Cwd;
use Encode;
use File::Basename;
use File::Find;
use Getopt::Mixed 1.006;
use IO::Handle;
use Term::ReadKey;

($termwidth)=GetTerminalSize(STDERR);
$splitline="-" x $termwidth;

Getopt::Mixed::init("r recursive>r n no-path>n h help>h usage>h d debug>d D stdebug>D a albums>a v version>v p=s pattern>p");
$Getopt::Mixed::ignoreCase = 0;
Getopt::Mixed::getOptions();

if ($opt_h) {
  print "Usage: m3ugen [OPTION]... SOURCE [M3UFILE]\n";
  print "Output an m3u playlist containing mp3, Ogg Vorbis, and FLAC files found in\n";
  print "SOURCE to M3UFILE if specified, STDOUT otherwise.\n\n";
  print "PATTERN specifies the pattern to use when writing the M3U info line using\n";
  print "the following variables: %a = artist, %t = track title, %n = track number\n";
  print "                         %b = album, %d = disc number [if available]\n\n";
  print "  -h, --help         display this screen and exit\n\n";
  print "  -r, --recursive    recursively search through directories\n";
  print "                     (default is specified directory ONLY)\n\n";
  print "  -a, --albums       create ALBUMNAME.m3u for each album in SOURCE\n";
  print "                     (implies M3UFILE behavior and ignores M3UFILE if specified)\n\n";
  print "  -n, --no-path      print paths relative to SOURCE\n";
  print "                     (default is to print full path)\n\n";
  print "  -p PATTERN,        quoted pattern to use for printing title in M3UFILE\n";
  print "  --pattern=PATTERN  (Examples: '%n - %t' or '%a.%b.%t')\n\n";
  print "  -d, --debug        print debugging output to STDERR\n";
  print "  -D, --stdebug      print debugging output to STDOUT\n\n";
  print "  -v, --version      print version information and exit\n\n";
  exit 0;
}

if ($opt_v) {
  print "m3ugen $version\n";
  exit 0;
}

if (!$ARGV[0]) {
  die "Please specify a directory to work on!\n\n";
}elsif (!-d $ARGV[0]) {
  die "Invalid directory!\n\n";
}

if ($ARGV[1]) {
  open(OUTPUT,">:utf8",$ARGV[1]) || die "Could not open $ARGV[1] for writing!\n";
}else {
  OUTPUT->fdopen(STDOUT, "w") || die "Could not redirect output!\n";
  binmode OUTPUT, ":utf8";
}

open(ERROR,">:utf8", "/dev/null");

if ($opt_d) {
  ERROR->fdopen(STDERR, "w");
  binmode ERROR, ":utf8";
}elsif ($opt_D) {
  ERROR->fdopen(STDOUT, "w");
  binmode ERROR, ":utf8";
}

print ERROR "SOURCE = \"$ARGV[0]\"\nM3UFILE = \"$ARGV[1]\"\n";

$workDir = mkvalidutf(Cwd::abs_path($ARGV[0])."/");

$currentDir = getcwd();

#for creating unique track numbers
$uniq = 1;

if (substr($workDir,0,1) ne '/') {
  $workDir = getcwd()."\/".$workDir;
}

if ($opt_r) {
  find(\&wanted, $workDir);
}else {
  chdir($workDir);
  foreach (glob("*.[Oo][Gg][Gg]"),glob("*.[Ff][Ll][Aa][Cc]"),glob("*.[Mm][Pp]3")) {
    print ERROR "found file = \"$_\"\n";
    push(@files,$workDir.$_);
  }
}

foreach $filename (@files) {
  $filename = decode_utf8($filename);
  print ERROR "$splitline";
  print ERROR "Processing filename = \"$filename\"\n";
  my $mediaFile = Audio::File->new("$filename");
  print ERROR "Loaded mediaFile\n";
  $artist = mkvalidutf($mediaFile->tag->artist());
  print ERROR "Loaded artist (\"$artist\")\n";
  $album = mkvalidutf($mediaFile->tag->album());
  print ERROR "Loaded album (\"$album\")\n";
  $disc = $mediaFile->tag->disc();
  print ERROR "Loaded disc (\"$disc\")\n";
  $track = abs($mediaFile->tag->track());
  print ERROR "Loaded track (\"$track\")\n";
  $title = mkvalidutf($mediaFile->tag->title());
  print ERROR "Loaded title (\"$title\")\n";
  $length = $mediaFile->audio_properties->length();
  print ERROR "Loaded length (\"$length\")\n";

  # The reason we're checking both track and album at the same time
  # here is because if we don't know the album the user is probably
  # generating a list for a directory of random songs, likely from
  # random albums. In this case, we assign a generic album name and
  # track number.
  #
  # TODO: This could be made more intelligent so that if the album
  # name doesn't exist but the track number does, we use the track
  # number IF it doesn't conflict with another one. If it does, we
  # give it one of the remaining available numbers.
  #
  # TODO: If the album is known but the tracks aren't, we could
  # still keep the album name. This poses problems if the user has
  # used the -a option, as this will open us to the possibility of
  # creating n random playlists. Perhaps finding an album name with
  # no track number will automatically disable the -a option?

  if (!$track || !$album) {
    print ERROR "Unknown album/track name\n";
    print ERROR "Assuming \"Unknown Album Name\" due to \"$album\".\n";
    print ERROR "Assuming track \"".$uniq++."\" due to \"$track\".\n";
    $album = "Unknown Album Name";
    $track = $uniq;
  }

  if (!$disc) {
    print ERROR "Unknown disc number. Assuming 1.\n";
    $disc = 1;
  }

  $m3ulines = "#EXTINF:".$length.","; #default info
  if ($opt_p) {
    my $formattedline = $opt_p;

    $formattedline =~ s/%a/$artist/g;
    $formattedline =~ s/%b/$album/g;
    $formattedline =~ s/%d/$disc/g;
    $formattedline =~ s/%n/$track/g;
    $formattedline =~ s/%t/$title/g;
    $m3ulines .= $formattedline;
  }else{
    $m3ulines .= $artist." - ".$title;
  }
  $m3ulines .= "\n";

  if ($opt_n) {
    $m3ulines .= basename($filename);
  }else {
    $m3ulines .= $filename;
  }
  $m3ulines .= "\n";

  $writeme{$album}[$disc - 1][$track - 1] = $m3ulines;
  print ERROR "m3ulines = \"$m3ulines\"\n";
}

$needextm3u = 1;

foreach $albumname (keys %writeme) {
  if ($opt_a) {
    print ERROR "$splitline";
    print ERROR "Generating -a list\n";
    close OUTPUT;
    open(OUTPUT,">:utf8", "$currentDir/$albumname.m3u") || die "Could not open $albumname.m3u for writing!\n";
  }else{
    print ERROR "Generating standard list\n";
  }
  if ($needextm3u) {
    print OUTPUT "#EXTM3U\n";
    $needextm3u = 0;
  }
  print ERROR "albumname = \"$albumname\"\n";
  for ($discnumber = 0; $discnumber < ($#{$writeme{$albumname}} + 1); $discnumber++) {
    print ERROR "discnumber = \"".($discnumber+1)."\"\n";
    foreach $songname (@{$writeme{$albumname}[$discnumber]}) {
      print OUTPUT $songname;
    }
  }
}

close ERROR;
close OUTPUT;

sub wanted {
  $_ = mkvalidutf($_);
  if (-f $_) {
    print ERROR "$splitline";
    print ERROR "checking \"$_\"\n";
    my @fileParts = split(/\./);
    my $fileExt = lc(pop(@fileParts));
    print ERROR "fileExt = \"$fileExt\"\n";
    if ($fileExt eq "ogg" || $fileExt eq "flac" || $fileExt eq "mp3") {
      print ERROR "adding \"$_\" to \@files\n";
      push(@files, $File::Find::name);
    }
  }
}

sub mkvalidutf {
  if (!utf8::is_utf8($_[0])) {
    return decode_utf8($_[0]);
  }else{
    return $_[0];
  }
}
